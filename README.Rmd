---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# benjaminileaves

<!-- badges: start -->
[![Lifecycle: experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://lifecycle.r-lib.org/articles/stages.html#experimental)
[![CRAN status](https://www.r-pkg.org/badges/version/benjaminileaves)](https://CRAN.R-project.org/package=benjaminileaves)
<!-- badges: end -->

## Generate benjamini leaves with bezier curves

The goal of this package is to generate shapes in the form of ficus benjamina leaves ([weeping fig](https://en.wikipedia.org/wiki/Ficus_benjamina))
with bezier curves. 

## Installation

You can install the newest version of benjaminileaves from github with:

``` r
# install.packages("remotes")
# (if not installed yet)

remotes::install_github("urswilke/benjaminileaves")
```




## Usage

First load some libraries:

```{r loadlibs, message=FALSE}
library(benjaminileaves)
library(purrr)
library(dplyr)
library(tidyr)
library(ggplot2)
set.seed(123)
```

## Illustration of the generated data

The package generates bezier curves that imitate the shape of the leaves of a
ficus benjamini. 
The main function is `benjamini_leaf()`: 


```{r fun}
df <- benjamini_leaf()
print(df, n = 40)
```
It results in a dataframe of multiple bezier curves representing the shape of a leaf. 
The first column `element` indicates which part of the leaf the bezier describes, 
and can take the values 
`r glue::glue('"{unique(benjamini_leaf()$element)}"') %>% glue::glue_collapse(sep = ", ", last = " and ")`.
`i_part` denotes the id of the bezier curve, and `x` & `y` its point coordinates.
The column `param_type` denotes the type of the point in the bezier curve.

The meaning is best illustrated with a plot:
```{r def}
# rearrange data to display segments:
segments <- df %>% 
  select(-param_type) %>% 
  group_by(element, i_part) %>% 
  mutate(j = c(1, 2, 1, 2)) %>%
  ungroup() %>% 
  pivot_wider(
    names_from = j,
    values_from = c(x, y),
    values_fn = list
  ) %>% 
  unnest(c(x_1, x_2, y_1, y_2))



ggplot(df, aes(x = x, y = y)) + 
  geom_point(color = "red") +
  geom_point(data = df %>% group_by(element, i_part) %>% slice(c(1, 4)), color = "blue", size = 2) +
  geom_point(data = df %>% slice(1), color = "black", size = 3) +
  ggforce::geom_bezier(aes(group = interaction(element, i_part), color = factor(i_part))) +
  geom_segment(
    data = segments, 
    aes(
      x = x_1, 
      xend = x_2, 
      y = y_1, 
      yend = y_2
    ), 
    linetype = "dotted", 
    color = "red"
  ) +
  coord_equal() +
  theme_minimal()
```

The black point represents the leaf origin. This and the blue points denote the
start/end points of the bezier curves, and the red dots the positions of the
control points. The leaf is cut in two halves (`element == "half 1" OR "half 2"`) by the lines where `i_part == 4` (which
represents the midvein of the leaf). The exact dimensions of these coordinates
are generated by random numbers in certain ranges (see the definition of the
argument `leaf_params` in `benjamini_leaf()`).


## Illustration of the randomness

In order to show the variations of the `benjamini_leaf()` (if parameters are not
explicitly specified), let's only pass the position of the leaf origins and let
the function randomly generate the rest of the shapes:

```{r plotlotsofbenjamini}
dfb <- expand_grid(
    x = seq(0, 200, 50),
    y = seq(25, 125, 25)
) %>%
  transpose() %>%
  map_dfr(~benjamini_leaf(gen_leaf_parameters(x0 = .x$x, y0 = .x$y)), .id = "i_leaf") %>%
  unite(i, i_leaf, i_part, element, remove = FALSE)

ggplot(dfb) +
  ggforce::geom_bezier(aes(x = x, y = y, group = i)) +
  # geom_point(data = l_points %>% bind_rows(), aes(x = x, y = y), color = "red") +
  coord_equal() +
  theme_minimal()
```


## Branches

You can also generate branches of leaves with the command `benjamini_branch()` (see the vignettes `vignette("create_benjamini_polygons")` and `vignette("create_benjamini_tree")` for examples):

```{r branch}
df_branch <- benjamini_branch() %>%
  # we add an identifier `b`:
  tidyr::unite(b, i_part, i_branch, element, remove = FALSE) 
df_branch
df_branch %>%
  ggplot2::ggplot() +
  ggforce::geom_bezier(ggplot2::aes(x = x, y = y, group = b, color = i_branch)) +
  ggplot2::coord_equal()
```

## Polygons

If you want to fill the leaves with color, you can use `gen_leaf_bezier_coords()` to approximate the leaf parts described by bezier curves with polygons:

```{r polygon}
df_branch %>% 
    filter(stringr::str_detect(element, "^half [12]$")) %>%
    unite(idx, i_branch, element, remove = FALSE) %>%
    gen_leaf_bezier_coords(idx, i_branch, element, i_part, n = 100) %>% 
  ggplot(
    data = .,
    aes(x = x, y = y, group = idx, fill = i_branch)
  ) +
  geom_polygon(show.legend = FALSE, color = "black") +
  theme_void() + 
  scale_color_gradientn(colours = c("darkgreen", "green"))
```

If you want to know more have a look in `vignette("create_benjamini_polygons")` .

## svg

You can also transform the leaf data to svgs. Have a look in `vignette("create_benjamini_svg")` for an example to generate [svg](vignettes/svg_vignette_output.svg) images.
